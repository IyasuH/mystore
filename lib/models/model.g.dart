// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'model.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:Personal.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// Personal TABLE
class TablePersonal extends SqfEntityTableBase {
  TablePersonal() {
    // declare properties of EntityTable
    tableName = 'personal';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('createdAt', DbType.datetime,
          defaultValue: DateTime.now(),
          isNotNull: true,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('updatedAt', DbType.datetime,
          defaultValue: DateTime.now(),
          isNotNull: true,
          minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePersonal();
  }
}

// Bank TABLE
class TableBank extends SqfEntityTableBase {
  TableBank() {
    // declare properties of EntityTable
    tableName = 'Bank';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('accountNumber', DbType.text, isNotNull: true),
      SqfEntityFieldBase('amount', DbType.real, isNotNull: true),
      SqfEntityFieldBase('accountDate', DbType.date,
          defaultValue: DateTime.now(),
          isNotNull: true,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('createdAt', DbType.datetime,
          defaultValue: DateTime.now(),
          isNotNull: true,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('updatedAt', DbType.datetime,
          defaultValue: DateTime.now(),
          isNotNull: true,
          minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBank();
  }
}

// Item TABLE
class TableItem extends SqfEntityTableBase {
  TableItem() {
    // declare properties of EntityTable
    tableName = 'Item';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('quantity', DbType.integer, isNotNull: true),
      SqfEntityFieldBase('singlePrice', DbType.real, isNotNull: true),
      SqfEntityFieldBase('bulkPrice', DbType.real, isNotNull: true),
      SqfEntityFieldBase('purchaseFreq', DbType.integer,
          defaultValue: 0, isNotNull: true),
      SqfEntityFieldBase('totPurchase', DbType.real, isNotNull: true),
      SqfEntityFieldBase('createdAt', DbType.datetime,
          defaultValue: DateTime.now(),
          isNotNull: true,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('updatedAt', DbType.datetime,
          defaultValue: DateTime.now(),
          isNotNull: true,
          minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableItem();
  }
}

// Client TABLE
class TableClient extends SqfEntityTableBase {
  TableClient() {
    // declare properties of EntityTable
    tableName = 'Client';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('companyName', DbType.text, isNotNull: true),
      SqfEntityFieldBase('bankName', DbType.text),
      SqfEntityFieldBase('bankNumber', DbType.text),
      SqfEntityFieldBase('tinNumber', DbType.text),
      SqfEntityFieldBase('city', DbType.text, isNotNull: true),
      SqfEntityFieldBase('phoneN', DbType.text, isNotNull: true),
      SqfEntityFieldBase('purchaseFreq', DbType.integer,
          defaultValue: 0, isNotNull: true),
      SqfEntityFieldBase('totPurchase', DbType.real, isNotNull: true),
      SqfEntityFieldBase('createdAt', DbType.datetime,
          defaultValue: DateTime.now(),
          isNotNull: true,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('updatedAt', DbType.datetime,
          defaultValue: DateTime.now(),
          isNotNull: true,
          minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableClient();
  }
}

// Expense TABLE
class TableExpense extends SqfEntityTableBase {
  TableExpense() {
    // declare properties of EntityTable
    tableName = 'Expense';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('amount', DbType.real, isNotNull: true),
      SqfEntityFieldBase('type', DbType.text,
          defaultValue: 'Fixed', isNotNull: true),
      SqfEntityFieldBase('date', DbType.date,
          defaultValue: DateTime.now(),
          isNotNull: true,
          minValue: DateTime.parse('1900-01-01'),
          maxValue: DateTime.now()),
      SqfEntityFieldBase('createdAt', DbType.datetime,
          defaultValue: DateTime.now(),
          isNotNull: true,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('updatedAt', DbType.datetime,
          defaultValue: DateTime.now(),
          isNotNull: true,
          minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableExpense();
  }
}

// Sale TABLE
class TableSale extends SqfEntityTableBase {
  TableSale() {
    // declare properties of EntityTable
    tableName = 'Sales';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(TableItem.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'ItemId'),
      SqfEntityFieldRelationshipBase(
          TableClient.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'ClientId'),
      SqfEntityFieldRelationshipBase(TableBank.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'BankId'),
      SqfEntityFieldBase('quantity', DbType.integer,
          defaultValue: 1, isNotNull: true),
      SqfEntityFieldBase('date', DbType.date,
          defaultValue: DateTime.now(),
          isNotNull: true,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('revenue', DbType.real, isNotNull: true),
      SqfEntityFieldBase('info', DbType.text, defaultValue: ''),
      SqfEntityFieldBase('createdAt', DbType.datetime,
          defaultValue: DateTime.now(),
          isNotNull: true,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('updatedAt', DbType.datetime,
          defaultValue: DateTime.now(),
          isNotNull: true,
          minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSale();
  }
}
// END TABLES

// BEGIN SEQUENCES
// identity SEQUENCE
class SequenceIdentitySequence extends SqfEntitySequenceBase {
  SequenceIdentitySequence() {
    sequenceName = 'identity';
    maxValue =
        9007199254740991; /* optional. default is max int (9.223.372.036.854.775.807) */
    cycle = false; /* optional. default is false; */
    minValue = 0; /* optional. default is 0 */
    incrementBy = 1; /* optional. default is 1 */
    startWith = 0; /* optional. default is 0 */
    super.init();
  }
  static SequenceIdentitySequence? _instance;
  static SequenceIdentitySequence get getInstance {
    return _instance = _instance ?? SequenceIdentitySequence();
  }
}
// END SEQUENCES

// BEGIN DATABASE MODEL
class MyStoreDbModel extends SqfEntityModelProvider {
  MyStoreDbModel() {
    databaseName = myDbModel.databaseName;
    password = myDbModel.password;
    dbVersion = myDbModel.dbVersion;
    preSaveAction = myDbModel.preSaveAction;
    logFunction = myDbModel.logFunction;
    databaseTables = [
      TablePersonal.getInstance,
      TableBank.getInstance,
      TableItem.getInstance,
      TableClient.getInstance,
      TableExpense.getInstance,
      TableSale.getInstance,
    ];

    sequences = [
      SequenceIdentitySequence.getInstance,
    ];

    bundledDatabasePath = myDbModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = myDbModel.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};
    controllers['personal'] = PersonalController.getController;
    controllers['bank'] = BankController.getController;
    controllers['item'] = ItemController.getController;
    controllers['client'] = ClientController.getController;
    controllers['expense'] = ExpenseController.getController;
    controllers['sales'] = SaleController.getController;

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region Personal
class Personal extends TableBase {
  Personal({this.id, this.name, this.createdAt, this.updatedAt}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Personal.withFields(this.name, this.createdAt, this.updatedAt) {
    _setDefaultValues();
  }
  Personal.withId(this.id, this.name, this.createdAt, this.updatedAt) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Personal.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['createdAt'] != null) {
      createdAt = int.tryParse(o['createdAt'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['createdAt'].toString())!)
          : DateTime.tryParse(o['createdAt'].toString());
    }
    if (o['updatedAt'] != null) {
      updatedAt = int.tryParse(o['updatedAt'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['updatedAt'].toString())!)
          : DateTime.tryParse(o['updatedAt'].toString());
    }
  }
  // FIELDS (Personal)
  int? id;
  String? name;
  DateTime? createdAt;
  DateTime? updatedAt;

  // end FIELDS (Personal)

  static const bool _softDeleteActivated = false;
  PersonalManager? __mnPersonal;

  PersonalManager get _mnPersonal {
    return __mnPersonal = __mnPersonal ?? PersonalManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (createdAt != null) {
      map['createdAt'] = forJson
          ? createdAt!.toString()
          : forQuery
              ? createdAt!.millisecondsSinceEpoch
              : createdAt;
    } else if (createdAt != null || !forView) {
      map['createdAt'] = null;
    }
    if (updatedAt != null) {
      map['updatedAt'] = forJson
          ? updatedAt!.toString()
          : forQuery
              ? updatedAt!.millisecondsSinceEpoch
              : updatedAt;
    } else if (updatedAt != null || !forView) {
      map['updatedAt'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (createdAt != null) {
      map['createdAt'] = forJson
          ? createdAt!.toString()
          : forQuery
              ? createdAt!.millisecondsSinceEpoch
              : createdAt;
    } else if (createdAt != null || !forView) {
      map['createdAt'] = null;
    }
    if (updatedAt != null) {
      map['updatedAt'] = forJson
          ? updatedAt!.toString()
          : forQuery
              ? updatedAt!.millisecondsSinceEpoch
              : updatedAt;
    } else if (updatedAt != null || !forView) {
      map['updatedAt'] = null;
    }

    return map;
  }

  /// This method returns Json String [Personal]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Personal]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      name,
      createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
      updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      name,
      createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
      updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
    ];
  }

  static Future<List<Personal>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Personal.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Personal>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Personal>[];
    try {
      objList = list
          .map((personal) => Personal.fromMap(personal as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Personal.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Personal>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Personal> objList = <Personal>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Personal.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Personal by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Personal] if exist, otherwise returns null
  Future<Personal?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Personal? obj;
    final data = await _mnPersonal.getById([id]);
    if (data.length != 0) {
      obj = Personal.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Personal) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnPersonal.insert(this, ignoreBatch);
    } else {
      await _mnPersonal.update(this);
    }

    return id;
  }

  /// Saves the (Personal) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnPersonal.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPersonal.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Personal. Returns a new Primary Key value of Personal

  /// <returns>Returns a new Primary Key value of Personal
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Personal> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Personal> personals,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyStoreDbModel().batchStart();
    for (final obj in personals) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyStoreDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < personals.length; i++) {
        if (personals[i].id == null) {
          personals[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPersonal.rawInsert(
          'INSERT OR REPLACE INTO personal (id, name, createdAt, updatedAt)  VALUES (?,?,?,?)',
          [
            id,
            name,
            createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
            updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Personal id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Personal id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Personal Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Personal>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Personal> personals,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnPersonal.rawInsertAll(
        'INSERT OR REPLACE INTO personal (id, name, createdAt, updatedAt)  VALUES (?,?,?,?)',
        personals,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Personal

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Personal invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnPersonal
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnPersonal.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Personal] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  PersonalFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PersonalFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  PersonalFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PersonalFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    createdAt = createdAt ?? DateTime.now();
    updatedAt = updatedAt ?? DateTime.now();
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion personal

// region PersonalField
class PersonalField extends FilterBase {
  PersonalField(PersonalFilterBuilder personalFB) : super(personalFB);

  @override
  PersonalFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as PersonalFilterBuilder;
  }

  @override
  PersonalFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as PersonalFilterBuilder;
  }

  @override
  PersonalFilterBuilder isNull() {
    return super.isNull() as PersonalFilterBuilder;
  }

  @override
  PersonalFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as PersonalFilterBuilder;
  }

  @override
  PersonalFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as PersonalFilterBuilder;
  }

  @override
  PersonalFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as PersonalFilterBuilder;
  }

  @override
  PersonalFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as PersonalFilterBuilder;
  }

  @override
  PersonalFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as PersonalFilterBuilder;
  }

  @override
  PersonalFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as PersonalFilterBuilder;
  }

  @override
  PersonalFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as PersonalFilterBuilder;
  }

  @override
  PersonalFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as PersonalFilterBuilder;
  }

  @override
  PersonalFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as PersonalFilterBuilder;
  }

  @override
  PersonalField get not {
    return super.not as PersonalField;
  }
}
// endregion PersonalField

// region PersonalFilterBuilder
class PersonalFilterBuilder extends ConjunctionBase {
  PersonalFilterBuilder(Personal obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnPersonal = obj._mnPersonal;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  PersonalManager? _mnPersonal;

  /// put the sql keyword 'AND'
  @override
  PersonalFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  PersonalFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  PersonalFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  PersonalFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  PersonalFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  PersonalFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  PersonalFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PersonalFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PersonalFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PersonalFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PersonalFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  PersonalField _setField(PersonalField? field, String colName, DbType dbtype) {
    return PersonalField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  PersonalField? _id;
  PersonalField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  PersonalField? _name;
  PersonalField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  PersonalField? _createdAt;
  PersonalField get createdAt {
    return _createdAt = _setField(_createdAt, 'createdAt', DbType.datetime);
  }

  PersonalField? _updatedAt;
  PersonalField get updatedAt {
    return _updatedAt = _setField(_updatedAt, 'updatedAt', DbType.datetime);
  }

  /// Deletes List<Personal> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnPersonal!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnPersonal!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from personal ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnPersonal!.updateBatch(qparams, values);
  }

  /// This method always returns [Personal] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Personal?
  @override
  Future<Personal?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnPersonal!.toList(qparams);
    final data = await objFuture;
    Personal? obj;
    if (data.isNotEmpty) {
      obj = Personal.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Personal]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Personal?
  @override
  Future<Personal> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Personal();
  }

  /// This method returns int. [Personal]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? personalCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final personalsFuture = await _mnPersonal!.toList(qparams);
    final int count = personalsFuture[0]['CNT'] as int;
    if (personalCount != null) {
      personalCount(count);
    }
    return count;
  }

  /// This method returns List<Personal> [Personal]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Personal>
  @override
  Future<List<Personal>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Personal> personalsData = await Personal.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return personalsData;
  }

  /// This method returns Json String [Personal]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Personal]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Personal]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnPersonal!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Personal>>
  Future<List<DropdownMenuItem<Personal>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Personal>> o)?
          dropDownMenu]) async {
    buildParameters();
    final personalsFuture = _mnPersonal!.toList(qparams);

    final data = await personalsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Personal>> items = []..add(DropdownMenuItem(
        value: Personal(),
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Personal.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final personalsFuture = _mnPersonal!.toList(qparams);

    final data = await personalsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Personal]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM personal WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnPersonal!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Personal]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnPersonal!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Personal.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnPersonal!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PersonalFilterBuilder

// region PersonalFields
class PersonalFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fCreatedAt;
  static TableField get createdAt {
    return _fCreatedAt = _fCreatedAt ??
        SqlSyntax.setField(_fCreatedAt, 'createdAt', DbType.datetime);
  }

  static TableField? _fUpdatedAt;
  static TableField get updatedAt {
    return _fUpdatedAt = _fUpdatedAt ??
        SqlSyntax.setField(_fUpdatedAt, 'updatedAt', DbType.datetime);
  }
}
// endregion PersonalFields

//region PersonalManager
class PersonalManager extends SqfEntityProvider {
  PersonalManager()
      : super(MyStoreDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'personal';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion PersonalManager
// region Bank
class Bank extends TableBase {
  Bank(
      {this.id,
      this.name,
      this.accountNumber,
      this.amount,
      this.accountDate,
      this.createdAt,
      this.updatedAt}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Bank.withFields(this.name, this.accountNumber, this.amount, this.accountDate,
      this.createdAt, this.updatedAt) {
    _setDefaultValues();
  }
  Bank.withId(this.id, this.name, this.accountNumber, this.amount,
      this.accountDate, this.createdAt, this.updatedAt) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Bank.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['accountNumber'] != null) {
      accountNumber = o['accountNumber'].toString();
    }
    if (o['amount'] != null) {
      amount = double.tryParse(o['amount'].toString());
    }
    if (o['accountDate'] != null) {
      accountDate = int.tryParse(o['accountDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['accountDate'].toString())!)
          : DateTime.tryParse(o['accountDate'].toString());
    }
    if (o['createdAt'] != null) {
      createdAt = int.tryParse(o['createdAt'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['createdAt'].toString())!)
          : DateTime.tryParse(o['createdAt'].toString());
    }
    if (o['updatedAt'] != null) {
      updatedAt = int.tryParse(o['updatedAt'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['updatedAt'].toString())!)
          : DateTime.tryParse(o['updatedAt'].toString());
    }
  }
  // FIELDS (Bank)
  int? id;
  String? name;
  String? accountNumber;
  double? amount;
  DateTime? accountDate;
  DateTime? createdAt;
  DateTime? updatedAt;

  // end FIELDS (Bank)

// COLLECTIONS & VIRTUALS (Bank)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSales', 'plField2'..]) or so on..
  List<Sale>? plSales;

  /// get Sale(s) filtered by id=BankId
  SaleFilterBuilder? getSales(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Sale()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .BankId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Bank)

  static const bool _softDeleteActivated = false;
  BankManager? __mnBank;

  BankManager get _mnBank {
    return __mnBank = __mnBank ?? BankManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (accountNumber != null || !forView) {
      map['accountNumber'] = accountNumber;
    }
    if (amount != null || !forView) {
      map['amount'] = amount;
    }
    if (accountDate != null) {
      map['accountDate'] = forJson
          ? '$accountDate!.year-$accountDate!.month-$accountDate!.day'
          : forQuery
              ? DateTime(
                      accountDate!.year, accountDate!.month, accountDate!.day)
                  .millisecondsSinceEpoch
              : accountDate;
    } else if (accountDate != null || !forView) {
      map['accountDate'] = null;
    }
    if (createdAt != null) {
      map['createdAt'] = forJson
          ? createdAt!.toString()
          : forQuery
              ? createdAt!.millisecondsSinceEpoch
              : createdAt;
    } else if (createdAt != null || !forView) {
      map['createdAt'] = null;
    }
    if (updatedAt != null) {
      map['updatedAt'] = forJson
          ? updatedAt!.toString()
          : forQuery
              ? updatedAt!.millisecondsSinceEpoch
              : updatedAt;
    } else if (updatedAt != null || !forView) {
      map['updatedAt'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (accountNumber != null || !forView) {
      map['accountNumber'] = accountNumber;
    }
    if (amount != null || !forView) {
      map['amount'] = amount;
    }
    if (accountDate != null) {
      map['accountDate'] = forJson
          ? '$accountDate!.year-$accountDate!.month-$accountDate!.day'
          : forQuery
              ? DateTime(
                      accountDate!.year, accountDate!.month, accountDate!.day)
                  .millisecondsSinceEpoch
              : accountDate;
    } else if (accountDate != null || !forView) {
      map['accountDate'] = null;
    }
    if (createdAt != null) {
      map['createdAt'] = forJson
          ? createdAt!.toString()
          : forQuery
              ? createdAt!.millisecondsSinceEpoch
              : createdAt;
    } else if (createdAt != null || !forView) {
      map['createdAt'] = null;
    }
    if (updatedAt != null) {
      map['updatedAt'] = forJson
          ? updatedAt!.toString()
          : forQuery
              ? updatedAt!.millisecondsSinceEpoch
              : updatedAt;
    } else if (updatedAt != null || !forView) {
      map['updatedAt'] = null;
    }

// COLLECTIONS (Bank)
    if (!forQuery) {
      map['Sales'] = await getSales()!.toMapList();
    }
// END COLLECTIONS (Bank)

    return map;
  }

  /// This method returns Json String [Bank]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Bank]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      name,
      accountNumber,
      amount,
      accountDate != null ? accountDate!.millisecondsSinceEpoch : null,
      createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
      updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      name,
      accountNumber,
      amount,
      accountDate != null ? accountDate!.millisecondsSinceEpoch : null,
      createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
      updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
    ];
  }

  static Future<List<Bank>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Bank.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Bank>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Bank>[];
    try {
      objList = list
          .map((bank) => Bank.fromMap(bank as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Bank.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Bank>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Bank> objList = <Bank>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Bank.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Bank.plSales') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSales'))) {
          /*_loadedfields!.add('Bank.plSales'); */ obj.plSales = obj.plSales ??
              await obj.getSales()!.toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Bank by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Bank] if exist, otherwise returns null
  Future<Bank?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Bank? obj;
    final data = await _mnBank.getById([id]);
    if (data.length != 0) {
      obj = Bank.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Bank.plSales') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSales'))) {
          /*_loadedfields!.add('Bank.plSales'); */ obj.plSales = obj.plSales ??
              await obj.getSales()!.toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Bank) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnBank.insert(this, ignoreBatch);
    } else {
      await _mnBank.update(this);
    }

    return id;
  }

  /// Saves the (Bank) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnBank.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnBank.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Bank. Returns a new Primary Key value of Bank

  /// <returns>Returns a new Primary Key value of Bank
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Bank> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Bank> banks,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyStoreDbModel().batchStart();
    for (final obj in banks) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyStoreDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < banks.length; i++) {
        if (banks[i].id == null) {
          banks[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBank.rawInsert(
          'INSERT OR REPLACE INTO Bank (id, name, accountNumber, amount, accountDate, createdAt, updatedAt)  VALUES (?,?,?,?,?,?,?)',
          [
            id,
            name,
            accountNumber,
            amount,
            accountDate != null ? accountDate!.millisecondsSinceEpoch : null,
            createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
            updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'Bank id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Bank id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Bank Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Bank>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Bank> banks,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnBank.rawInsertAll(
        'INSERT OR REPLACE INTO Bank (id, name, accountNumber, amount, accountDate, createdAt, updatedAt)  VALUES (?,?,?,?,?,?,?)',
        banks,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Bank

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Bank invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await Sale().select().BankId.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnBank
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnBank.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Bank] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BankFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BankFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BankFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BankFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    accountDate = accountDate ?? DateTime.now();
    createdAt = createdAt ?? DateTime.now();
    updatedAt = updatedAt ?? DateTime.now();
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion bank

// region BankField
class BankField extends FilterBase {
  BankField(BankFilterBuilder bankFB) : super(bankFB);

  @override
  BankFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BankFilterBuilder;
  }

  @override
  BankFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BankFilterBuilder;
  }

  @override
  BankFilterBuilder isNull() {
    return super.isNull() as BankFilterBuilder;
  }

  @override
  BankFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BankFilterBuilder;
  }

  @override
  BankFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BankFilterBuilder;
  }

  @override
  BankFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BankFilterBuilder;
  }

  @override
  BankFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BankFilterBuilder;
  }

  @override
  BankFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BankFilterBuilder;
  }

  @override
  BankFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BankFilterBuilder;
  }

  @override
  BankFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BankFilterBuilder;
  }

  @override
  BankFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BankFilterBuilder;
  }

  @override
  BankFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BankFilterBuilder;
  }

  @override
  BankField get not {
    return super.not as BankField;
  }
}
// endregion BankField

// region BankFilterBuilder
class BankFilterBuilder extends ConjunctionBase {
  BankFilterBuilder(Bank obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnBank = obj._mnBank;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BankManager? _mnBank;

  /// put the sql keyword 'AND'
  @override
  BankFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BankFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BankFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BankFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BankFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BankFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BankFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BankFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BankFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BankFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BankFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BankField _setField(BankField? field, String colName, DbType dbtype) {
    return BankField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BankField? _id;
  BankField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  BankField? _name;
  BankField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  BankField? _accountNumber;
  BankField get accountNumber {
    return _accountNumber =
        _setField(_accountNumber, 'accountNumber', DbType.text);
  }

  BankField? _amount;
  BankField get amount {
    return _amount = _setField(_amount, 'amount', DbType.real);
  }

  BankField? _accountDate;
  BankField get accountDate {
    return _accountDate = _setField(_accountDate, 'accountDate', DbType.date);
  }

  BankField? _createdAt;
  BankField get createdAt {
    return _createdAt = _setField(_createdAt, 'createdAt', DbType.datetime);
  }

  BankField? _updatedAt;
  BankField get updatedAt {
    return _updatedAt = _setField(_updatedAt, 'updatedAt', DbType.datetime);
  }

  /// Deletes List<Bank> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (Sale) according to DeleteRule.CASCADE
    final idListSaleBYBankId = toListPrimaryKeySQL(false);
    final resSaleBYBankId = await Sale()
        .select()
        .where('BankId IN (${idListSaleBYBankId['sql']})',
            parameterValue: idListSaleBYBankId['args'])
        .delete(hardDelete);
    if (!resSaleBYBankId.success) {
      return resSaleBYBankId;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBank!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBank!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from Bank ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBank!.updateBatch(qparams, values);
  }

  /// This method always returns [Bank] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Bank?
  @override
  Future<Bank?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBank!.toList(qparams);
    final data = await objFuture;
    Bank? obj;
    if (data.isNotEmpty) {
      obj = Bank.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Bank.plSales') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSales'))) {
          /*_loadedfields!.add('Bank.plSales'); */ obj.plSales = obj.plSales ??
              await obj.getSales()!.toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Bank]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Bank?
  @override
  Future<Bank> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Bank();
  }

  /// This method returns int. [Bank]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? bankCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final banksFuture = await _mnBank!.toList(qparams);
    final int count = banksFuture[0]['CNT'] as int;
    if (bankCount != null) {
      bankCount(count);
    }
    return count;
  }

  /// This method returns List<Bank> [Bank]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Bank>
  @override
  Future<List<Bank>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Bank> banksData = await Bank.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return banksData;
  }

  /// This method returns Json String [Bank]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Bank]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Bank]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBank!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Bank>>
  Future<List<DropdownMenuItem<Bank>>> toDropDownMenu(String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Bank>> o)?
          dropDownMenu]) async {
    buildParameters();
    final banksFuture = _mnBank!.toList(qparams);

    final data = await banksFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Bank>> items = []..add(DropdownMenuItem(
        value: Bank(),
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Bank.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final banksFuture = _mnBank!.toList(qparams);

    final data = await banksFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Bank]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM Bank WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnBank!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Bank]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBank!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Bank.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBank!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BankFilterBuilder

// region BankFields
class BankFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fAccountNumber;
  static TableField get accountNumber {
    return _fAccountNumber = _fAccountNumber ??
        SqlSyntax.setField(_fAccountNumber, 'accountNumber', DbType.text);
  }

  static TableField? _fAmount;
  static TableField get amount {
    return _fAmount =
        _fAmount ?? SqlSyntax.setField(_fAmount, 'amount', DbType.real);
  }

  static TableField? _fAccountDate;
  static TableField get accountDate {
    return _fAccountDate = _fAccountDate ??
        SqlSyntax.setField(_fAccountDate, 'accountDate', DbType.date);
  }

  static TableField? _fCreatedAt;
  static TableField get createdAt {
    return _fCreatedAt = _fCreatedAt ??
        SqlSyntax.setField(_fCreatedAt, 'createdAt', DbType.datetime);
  }

  static TableField? _fUpdatedAt;
  static TableField get updatedAt {
    return _fUpdatedAt = _fUpdatedAt ??
        SqlSyntax.setField(_fUpdatedAt, 'updatedAt', DbType.datetime);
  }
}
// endregion BankFields

//region BankManager
class BankManager extends SqfEntityProvider {
  BankManager()
      : super(MyStoreDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Bank';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion BankManager
// region Item
class Item extends TableBase {
  Item(
      {this.id,
      this.name,
      this.quantity,
      this.singlePrice,
      this.bulkPrice,
      this.purchaseFreq,
      this.totPurchase,
      this.createdAt,
      this.updatedAt}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Item.withFields(this.name, this.quantity, this.singlePrice, this.bulkPrice,
      this.purchaseFreq, this.totPurchase, this.createdAt, this.updatedAt) {
    _setDefaultValues();
  }
  Item.withId(
      this.id,
      this.name,
      this.quantity,
      this.singlePrice,
      this.bulkPrice,
      this.purchaseFreq,
      this.totPurchase,
      this.createdAt,
      this.updatedAt) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Item.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['quantity'] != null) {
      quantity = int.tryParse(o['quantity'].toString());
    }
    if (o['singlePrice'] != null) {
      singlePrice = double.tryParse(o['singlePrice'].toString());
    }
    if (o['bulkPrice'] != null) {
      bulkPrice = double.tryParse(o['bulkPrice'].toString());
    }
    if (o['purchaseFreq'] != null) {
      purchaseFreq = int.tryParse(o['purchaseFreq'].toString());
    }
    if (o['totPurchase'] != null) {
      totPurchase = double.tryParse(o['totPurchase'].toString());
    }
    if (o['createdAt'] != null) {
      createdAt = int.tryParse(o['createdAt'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['createdAt'].toString())!)
          : DateTime.tryParse(o['createdAt'].toString());
    }
    if (o['updatedAt'] != null) {
      updatedAt = int.tryParse(o['updatedAt'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['updatedAt'].toString())!)
          : DateTime.tryParse(o['updatedAt'].toString());
    }
  }
  // FIELDS (Item)
  int? id;
  String? name;
  int? quantity;
  double? singlePrice;
  double? bulkPrice;
  int? purchaseFreq;
  double? totPurchase;
  DateTime? createdAt;
  DateTime? updatedAt;

  // end FIELDS (Item)

// COLLECTIONS & VIRTUALS (Item)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSales', 'plField2'..]) or so on..
  List<Sale>? plSales;

  /// get Sale(s) filtered by id=ItemId
  SaleFilterBuilder? getSales(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Sale()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .ItemId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Item)

  static const bool _softDeleteActivated = false;
  ItemManager? __mnItem;

  ItemManager get _mnItem {
    return __mnItem = __mnItem ?? ItemManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (quantity != null || !forView) {
      map['quantity'] = quantity;
    }
    if (singlePrice != null || !forView) {
      map['singlePrice'] = singlePrice;
    }
    if (bulkPrice != null || !forView) {
      map['bulkPrice'] = bulkPrice;
    }
    if (purchaseFreq != null || !forView) {
      map['purchaseFreq'] = purchaseFreq;
    }
    if (totPurchase != null || !forView) {
      map['totPurchase'] = totPurchase;
    }
    if (createdAt != null) {
      map['createdAt'] = forJson
          ? createdAt!.toString()
          : forQuery
              ? createdAt!.millisecondsSinceEpoch
              : createdAt;
    } else if (createdAt != null || !forView) {
      map['createdAt'] = null;
    }
    if (updatedAt != null) {
      map['updatedAt'] = forJson
          ? updatedAt!.toString()
          : forQuery
              ? updatedAt!.millisecondsSinceEpoch
              : updatedAt;
    } else if (updatedAt != null || !forView) {
      map['updatedAt'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (quantity != null || !forView) {
      map['quantity'] = quantity;
    }
    if (singlePrice != null || !forView) {
      map['singlePrice'] = singlePrice;
    }
    if (bulkPrice != null || !forView) {
      map['bulkPrice'] = bulkPrice;
    }
    if (purchaseFreq != null || !forView) {
      map['purchaseFreq'] = purchaseFreq;
    }
    if (totPurchase != null || !forView) {
      map['totPurchase'] = totPurchase;
    }
    if (createdAt != null) {
      map['createdAt'] = forJson
          ? createdAt!.toString()
          : forQuery
              ? createdAt!.millisecondsSinceEpoch
              : createdAt;
    } else if (createdAt != null || !forView) {
      map['createdAt'] = null;
    }
    if (updatedAt != null) {
      map['updatedAt'] = forJson
          ? updatedAt!.toString()
          : forQuery
              ? updatedAt!.millisecondsSinceEpoch
              : updatedAt;
    } else if (updatedAt != null || !forView) {
      map['updatedAt'] = null;
    }

// COLLECTIONS (Item)
    if (!forQuery) {
      map['Sales'] = await getSales()!.toMapList();
    }
// END COLLECTIONS (Item)

    return map;
  }

  /// This method returns Json String [Item]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Item]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      name,
      quantity,
      singlePrice,
      bulkPrice,
      purchaseFreq,
      totPurchase,
      createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
      updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      name,
      quantity,
      singlePrice,
      bulkPrice,
      purchaseFreq,
      totPurchase,
      createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
      updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
    ];
  }

  static Future<List<Item>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Item.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Item>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Item>[];
    try {
      objList = list
          .map((item) => Item.fromMap(item as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Item.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Item>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Item> objList = <Item>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Item.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Item.plSales') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSales'))) {
          /*_loadedfields!.add('Item.plSales'); */ obj.plSales = obj.plSales ??
              await obj.getSales()!.toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Item by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Item] if exist, otherwise returns null
  Future<Item?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Item? obj;
    final data = await _mnItem.getById([id]);
    if (data.length != 0) {
      obj = Item.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Item.plSales') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSales'))) {
          /*_loadedfields!.add('Item.plSales'); */ obj.plSales = obj.plSales ??
              await obj.getSales()!.toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Item) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnItem.insert(this, ignoreBatch);
    } else {
      await _mnItem.update(this);
    }

    return id;
  }

  /// Saves the (Item) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnItem.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnItem.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Item. Returns a new Primary Key value of Item

  /// <returns>Returns a new Primary Key value of Item
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Item> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Item> items,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyStoreDbModel().batchStart();
    for (final obj in items) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyStoreDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < items.length; i++) {
        if (items[i].id == null) {
          items[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnItem.rawInsert(
          'INSERT OR REPLACE INTO Item (id, name, quantity, singlePrice, bulkPrice, purchaseFreq, totPurchase, createdAt, updatedAt)  VALUES (?,?,?,?,?,?,?,?,?)',
          [
            id,
            name,
            quantity,
            singlePrice,
            bulkPrice,
            purchaseFreq,
            totPurchase,
            createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
            updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'Item id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Item id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Item Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Item>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Item> items,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnItem.rawInsertAll(
        'INSERT OR REPLACE INTO Item (id, name, quantity, singlePrice, bulkPrice, purchaseFreq, totPurchase, createdAt, updatedAt)  VALUES (?,?,?,?,?,?,?,?,?)',
        items,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Item

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Item invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await Sale().select().ItemId.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnItem
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnItem.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Item] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ItemFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ItemFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ItemFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ItemFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    purchaseFreq = purchaseFreq ?? 0;
    createdAt = createdAt ?? DateTime.now();
    updatedAt = updatedAt ?? DateTime.now();
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion item

// region ItemField
class ItemField extends FilterBase {
  ItemField(ItemFilterBuilder itemFB) : super(itemFB);

  @override
  ItemFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ItemFilterBuilder;
  }

  @override
  ItemFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ItemFilterBuilder;
  }

  @override
  ItemFilterBuilder isNull() {
    return super.isNull() as ItemFilterBuilder;
  }

  @override
  ItemFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ItemFilterBuilder;
  }

  @override
  ItemFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ItemFilterBuilder;
  }

  @override
  ItemFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ItemFilterBuilder;
  }

  @override
  ItemFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ItemFilterBuilder;
  }

  @override
  ItemFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ItemFilterBuilder;
  }

  @override
  ItemFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ItemFilterBuilder;
  }

  @override
  ItemFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ItemFilterBuilder;
  }

  @override
  ItemFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ItemFilterBuilder;
  }

  @override
  ItemFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ItemFilterBuilder;
  }

  @override
  ItemField get not {
    return super.not as ItemField;
  }
}
// endregion ItemField

// region ItemFilterBuilder
class ItemFilterBuilder extends ConjunctionBase {
  ItemFilterBuilder(Item obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnItem = obj._mnItem;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ItemManager? _mnItem;

  /// put the sql keyword 'AND'
  @override
  ItemFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ItemFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ItemFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ItemFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ItemFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ItemFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ItemFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ItemFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ItemFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ItemFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ItemFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ItemField _setField(ItemField? field, String colName, DbType dbtype) {
    return ItemField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ItemField? _id;
  ItemField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  ItemField? _name;
  ItemField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  ItemField? _quantity;
  ItemField get quantity {
    return _quantity = _setField(_quantity, 'quantity', DbType.integer);
  }

  ItemField? _singlePrice;
  ItemField get singlePrice {
    return _singlePrice = _setField(_singlePrice, 'singlePrice', DbType.real);
  }

  ItemField? _bulkPrice;
  ItemField get bulkPrice {
    return _bulkPrice = _setField(_bulkPrice, 'bulkPrice', DbType.real);
  }

  ItemField? _purchaseFreq;
  ItemField get purchaseFreq {
    return _purchaseFreq =
        _setField(_purchaseFreq, 'purchaseFreq', DbType.integer);
  }

  ItemField? _totPurchase;
  ItemField get totPurchase {
    return _totPurchase = _setField(_totPurchase, 'totPurchase', DbType.real);
  }

  ItemField? _createdAt;
  ItemField get createdAt {
    return _createdAt = _setField(_createdAt, 'createdAt', DbType.datetime);
  }

  ItemField? _updatedAt;
  ItemField get updatedAt {
    return _updatedAt = _setField(_updatedAt, 'updatedAt', DbType.datetime);
  }

  /// Deletes List<Item> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (Sale) according to DeleteRule.CASCADE
    final idListSaleBYItemId = toListPrimaryKeySQL(false);
    final resSaleBYItemId = await Sale()
        .select()
        .where('ItemId IN (${idListSaleBYItemId['sql']})',
            parameterValue: idListSaleBYItemId['args'])
        .delete(hardDelete);
    if (!resSaleBYItemId.success) {
      return resSaleBYItemId;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnItem!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnItem!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from Item ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnItem!.updateBatch(qparams, values);
  }

  /// This method always returns [Item] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Item?
  @override
  Future<Item?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnItem!.toList(qparams);
    final data = await objFuture;
    Item? obj;
    if (data.isNotEmpty) {
      obj = Item.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Item.plSales') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSales'))) {
          /*_loadedfields!.add('Item.plSales'); */ obj.plSales = obj.plSales ??
              await obj.getSales()!.toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Item]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Item?
  @override
  Future<Item> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Item();
  }

  /// This method returns int. [Item]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? itemCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final itemsFuture = await _mnItem!.toList(qparams);
    final int count = itemsFuture[0]['CNT'] as int;
    if (itemCount != null) {
      itemCount(count);
    }
    return count;
  }

  /// This method returns List<Item> [Item]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Item>
  @override
  Future<List<Item>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Item> itemsData = await Item.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return itemsData;
  }

  /// This method returns Json String [Item]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Item]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Item]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnItem!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Item>>
  Future<List<DropdownMenuItem<Item>>> toDropDownMenu(String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Item>> o)?
          dropDownMenu]) async {
    buildParameters();
    final itemsFuture = _mnItem!.toList(qparams);

    final data = await itemsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Item>> items = []..add(DropdownMenuItem(
        value: Item(),
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Item.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final itemsFuture = _mnItem!.toList(qparams);

    final data = await itemsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Item]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM Item WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnItem!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Item]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnItem!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Item.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnItem!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ItemFilterBuilder

// region ItemFields
class ItemFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fQuantity;
  static TableField get quantity {
    return _fQuantity = _fQuantity ??
        SqlSyntax.setField(_fQuantity, 'quantity', DbType.integer);
  }

  static TableField? _fSinglePrice;
  static TableField get singlePrice {
    return _fSinglePrice = _fSinglePrice ??
        SqlSyntax.setField(_fSinglePrice, 'singlePrice', DbType.real);
  }

  static TableField? _fBulkPrice;
  static TableField get bulkPrice {
    return _fBulkPrice = _fBulkPrice ??
        SqlSyntax.setField(_fBulkPrice, 'bulkPrice', DbType.real);
  }

  static TableField? _fPurchaseFreq;
  static TableField get purchaseFreq {
    return _fPurchaseFreq = _fPurchaseFreq ??
        SqlSyntax.setField(_fPurchaseFreq, 'purchaseFreq', DbType.integer);
  }

  static TableField? _fTotPurchase;
  static TableField get totPurchase {
    return _fTotPurchase = _fTotPurchase ??
        SqlSyntax.setField(_fTotPurchase, 'totPurchase', DbType.real);
  }

  static TableField? _fCreatedAt;
  static TableField get createdAt {
    return _fCreatedAt = _fCreatedAt ??
        SqlSyntax.setField(_fCreatedAt, 'createdAt', DbType.datetime);
  }

  static TableField? _fUpdatedAt;
  static TableField get updatedAt {
    return _fUpdatedAt = _fUpdatedAt ??
        SqlSyntax.setField(_fUpdatedAt, 'updatedAt', DbType.datetime);
  }
}
// endregion ItemFields

//region ItemManager
class ItemManager extends SqfEntityProvider {
  ItemManager()
      : super(MyStoreDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Item';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ItemManager
// region Client
class Client extends TableBase {
  Client(
      {this.id,
      this.name,
      this.companyName,
      this.bankName,
      this.bankNumber,
      this.tinNumber,
      this.city,
      this.phoneN,
      this.purchaseFreq,
      this.totPurchase,
      this.createdAt,
      this.updatedAt}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Client.withFields(
      this.name,
      this.companyName,
      this.bankName,
      this.bankNumber,
      this.tinNumber,
      this.city,
      this.phoneN,
      this.purchaseFreq,
      this.totPurchase,
      this.createdAt,
      this.updatedAt) {
    _setDefaultValues();
  }
  Client.withId(
      this.id,
      this.name,
      this.companyName,
      this.bankName,
      this.bankNumber,
      this.tinNumber,
      this.city,
      this.phoneN,
      this.purchaseFreq,
      this.totPurchase,
      this.createdAt,
      this.updatedAt) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Client.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['companyName'] != null) {
      companyName = o['companyName'].toString();
    }
    if (o['bankName'] != null) {
      bankName = o['bankName'].toString();
    }
    if (o['bankNumber'] != null) {
      bankNumber = o['bankNumber'].toString();
    }
    if (o['tinNumber'] != null) {
      tinNumber = o['tinNumber'].toString();
    }
    if (o['city'] != null) {
      city = o['city'].toString();
    }
    if (o['phoneN'] != null) {
      phoneN = o['phoneN'].toString();
    }
    if (o['purchaseFreq'] != null) {
      purchaseFreq = int.tryParse(o['purchaseFreq'].toString());
    }
    if (o['totPurchase'] != null) {
      totPurchase = double.tryParse(o['totPurchase'].toString());
    }
    if (o['createdAt'] != null) {
      createdAt = int.tryParse(o['createdAt'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['createdAt'].toString())!)
          : DateTime.tryParse(o['createdAt'].toString());
    }
    if (o['updatedAt'] != null) {
      updatedAt = int.tryParse(o['updatedAt'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['updatedAt'].toString())!)
          : DateTime.tryParse(o['updatedAt'].toString());
    }
  }
  // FIELDS (Client)
  int? id;
  String? name;
  String? companyName;
  String? bankName;
  String? bankNumber;
  String? tinNumber;
  String? city;
  String? phoneN;
  int? purchaseFreq;
  double? totPurchase;
  DateTime? createdAt;
  DateTime? updatedAt;

  // end FIELDS (Client)

// COLLECTIONS & VIRTUALS (Client)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSales', 'plField2'..]) or so on..
  List<Sale>? plSales;

  /// get Sale(s) filtered by id=ClientId
  SaleFilterBuilder? getSales(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Sale()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .ClientId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Client)

  static const bool _softDeleteActivated = false;
  ClientManager? __mnClient;

  ClientManager get _mnClient {
    return __mnClient = __mnClient ?? ClientManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (companyName != null || !forView) {
      map['companyName'] = companyName;
    }
    if (bankName != null || !forView) {
      map['bankName'] = bankName;
    }
    if (bankNumber != null || !forView) {
      map['bankNumber'] = bankNumber;
    }
    if (tinNumber != null || !forView) {
      map['tinNumber'] = tinNumber;
    }
    if (city != null || !forView) {
      map['city'] = city;
    }
    if (phoneN != null || !forView) {
      map['phoneN'] = phoneN;
    }
    if (purchaseFreq != null || !forView) {
      map['purchaseFreq'] = purchaseFreq;
    }
    if (totPurchase != null || !forView) {
      map['totPurchase'] = totPurchase;
    }
    if (createdAt != null) {
      map['createdAt'] = forJson
          ? createdAt!.toString()
          : forQuery
              ? createdAt!.millisecondsSinceEpoch
              : createdAt;
    } else if (createdAt != null || !forView) {
      map['createdAt'] = null;
    }
    if (updatedAt != null) {
      map['updatedAt'] = forJson
          ? updatedAt!.toString()
          : forQuery
              ? updatedAt!.millisecondsSinceEpoch
              : updatedAt;
    } else if (updatedAt != null || !forView) {
      map['updatedAt'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (companyName != null || !forView) {
      map['companyName'] = companyName;
    }
    if (bankName != null || !forView) {
      map['bankName'] = bankName;
    }
    if (bankNumber != null || !forView) {
      map['bankNumber'] = bankNumber;
    }
    if (tinNumber != null || !forView) {
      map['tinNumber'] = tinNumber;
    }
    if (city != null || !forView) {
      map['city'] = city;
    }
    if (phoneN != null || !forView) {
      map['phoneN'] = phoneN;
    }
    if (purchaseFreq != null || !forView) {
      map['purchaseFreq'] = purchaseFreq;
    }
    if (totPurchase != null || !forView) {
      map['totPurchase'] = totPurchase;
    }
    if (createdAt != null) {
      map['createdAt'] = forJson
          ? createdAt!.toString()
          : forQuery
              ? createdAt!.millisecondsSinceEpoch
              : createdAt;
    } else if (createdAt != null || !forView) {
      map['createdAt'] = null;
    }
    if (updatedAt != null) {
      map['updatedAt'] = forJson
          ? updatedAt!.toString()
          : forQuery
              ? updatedAt!.millisecondsSinceEpoch
              : updatedAt;
    } else if (updatedAt != null || !forView) {
      map['updatedAt'] = null;
    }

// COLLECTIONS (Client)
    if (!forQuery) {
      map['Sales'] = await getSales()!.toMapList();
    }
// END COLLECTIONS (Client)

    return map;
  }

  /// This method returns Json String [Client]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Client]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      name,
      companyName,
      bankName,
      bankNumber,
      tinNumber,
      city,
      phoneN,
      purchaseFreq,
      totPurchase,
      createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
      updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      name,
      companyName,
      bankName,
      bankNumber,
      tinNumber,
      city,
      phoneN,
      purchaseFreq,
      totPurchase,
      createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
      updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
    ];
  }

  static Future<List<Client>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Client.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Client>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Client>[];
    try {
      objList = list
          .map((client) => Client.fromMap(client as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Client.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Client>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Client> objList = <Client>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Client.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Client.plSales') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSales'))) {
          /*_loadedfields!.add('Client.plSales'); */ obj.plSales =
              obj.plSales ??
                  await obj.getSales()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Client by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Client] if exist, otherwise returns null
  Future<Client?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Client? obj;
    final data = await _mnClient.getById([id]);
    if (data.length != 0) {
      obj = Client.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Client.plSales') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSales'))) {
          /*_loadedfields!.add('Client.plSales'); */ obj.plSales =
              obj.plSales ??
                  await obj.getSales()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Client) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnClient.insert(this, ignoreBatch);
    } else {
      await _mnClient.update(this);
    }

    return id;
  }

  /// Saves the (Client) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnClient.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnClient.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Client. Returns a new Primary Key value of Client

  /// <returns>Returns a new Primary Key value of Client
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Client> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Client> clients,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyStoreDbModel().batchStart();
    for (final obj in clients) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyStoreDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < clients.length; i++) {
        if (clients[i].id == null) {
          clients[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnClient.rawInsert(
          'INSERT OR REPLACE INTO Client (id, name, companyName, bankName, bankNumber, tinNumber, city, phoneN, purchaseFreq, totPurchase, createdAt, updatedAt)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            name,
            companyName,
            bankName,
            bankNumber,
            tinNumber,
            city,
            phoneN,
            purchaseFreq,
            totPurchase,
            createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
            updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Client id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Client id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Client Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Client>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Client> clients,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnClient.rawInsertAll(
        'INSERT OR REPLACE INTO Client (id, name, companyName, bankName, bankNumber, tinNumber, city, phoneN, purchaseFreq, totPurchase, createdAt, updatedAt)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?)',
        clients,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Client

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Client invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await Sale().select().ClientId.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnClient
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnClient.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Client] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ClientFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ClientFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ClientFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ClientFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    purchaseFreq = purchaseFreq ?? 0;
    createdAt = createdAt ?? DateTime.now();
    updatedAt = updatedAt ?? DateTime.now();
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion client

// region ClientField
class ClientField extends FilterBase {
  ClientField(ClientFilterBuilder clientFB) : super(clientFB);

  @override
  ClientFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ClientFilterBuilder;
  }

  @override
  ClientFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ClientFilterBuilder;
  }

  @override
  ClientFilterBuilder isNull() {
    return super.isNull() as ClientFilterBuilder;
  }

  @override
  ClientFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ClientFilterBuilder;
  }

  @override
  ClientFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ClientFilterBuilder;
  }

  @override
  ClientFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ClientFilterBuilder;
  }

  @override
  ClientFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ClientFilterBuilder;
  }

  @override
  ClientFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ClientFilterBuilder;
  }

  @override
  ClientFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ClientFilterBuilder;
  }

  @override
  ClientFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ClientFilterBuilder;
  }

  @override
  ClientFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ClientFilterBuilder;
  }

  @override
  ClientFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ClientFilterBuilder;
  }

  @override
  ClientField get not {
    return super.not as ClientField;
  }
}
// endregion ClientField

// region ClientFilterBuilder
class ClientFilterBuilder extends ConjunctionBase {
  ClientFilterBuilder(Client obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnClient = obj._mnClient;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ClientManager? _mnClient;

  /// put the sql keyword 'AND'
  @override
  ClientFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ClientFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ClientFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ClientFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ClientFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ClientFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ClientFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ClientFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ClientFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ClientFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ClientFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ClientField _setField(ClientField? field, String colName, DbType dbtype) {
    return ClientField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ClientField? _id;
  ClientField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  ClientField? _name;
  ClientField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  ClientField? _companyName;
  ClientField get companyName {
    return _companyName = _setField(_companyName, 'companyName', DbType.text);
  }

  ClientField? _bankName;
  ClientField get bankName {
    return _bankName = _setField(_bankName, 'bankName', DbType.text);
  }

  ClientField? _bankNumber;
  ClientField get bankNumber {
    return _bankNumber = _setField(_bankNumber, 'bankNumber', DbType.text);
  }

  ClientField? _tinNumber;
  ClientField get tinNumber {
    return _tinNumber = _setField(_tinNumber, 'tinNumber', DbType.text);
  }

  ClientField? _city;
  ClientField get city {
    return _city = _setField(_city, 'city', DbType.text);
  }

  ClientField? _phoneN;
  ClientField get phoneN {
    return _phoneN = _setField(_phoneN, 'phoneN', DbType.text);
  }

  ClientField? _purchaseFreq;
  ClientField get purchaseFreq {
    return _purchaseFreq =
        _setField(_purchaseFreq, 'purchaseFreq', DbType.integer);
  }

  ClientField? _totPurchase;
  ClientField get totPurchase {
    return _totPurchase = _setField(_totPurchase, 'totPurchase', DbType.real);
  }

  ClientField? _createdAt;
  ClientField get createdAt {
    return _createdAt = _setField(_createdAt, 'createdAt', DbType.datetime);
  }

  ClientField? _updatedAt;
  ClientField get updatedAt {
    return _updatedAt = _setField(_updatedAt, 'updatedAt', DbType.datetime);
  }

  /// Deletes List<Client> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (Sale) according to DeleteRule.CASCADE
    final idListSaleBYClientId = toListPrimaryKeySQL(false);
    final resSaleBYClientId = await Sale()
        .select()
        .where('ClientId IN (${idListSaleBYClientId['sql']})',
            parameterValue: idListSaleBYClientId['args'])
        .delete(hardDelete);
    if (!resSaleBYClientId.success) {
      return resSaleBYClientId;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnClient!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnClient!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from Client ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnClient!.updateBatch(qparams, values);
  }

  /// This method always returns [Client] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Client?
  @override
  Future<Client?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnClient!.toList(qparams);
    final data = await objFuture;
    Client? obj;
    if (data.isNotEmpty) {
      obj = Client.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Client.plSales') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSales'))) {
          /*_loadedfields!.add('Client.plSales'); */ obj.plSales =
              obj.plSales ??
                  await obj.getSales()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Client]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Client?
  @override
  Future<Client> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Client();
  }

  /// This method returns int. [Client]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? clientCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final clientsFuture = await _mnClient!.toList(qparams);
    final int count = clientsFuture[0]['CNT'] as int;
    if (clientCount != null) {
      clientCount(count);
    }
    return count;
  }

  /// This method returns List<Client> [Client]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Client>
  @override
  Future<List<Client>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Client> clientsData = await Client.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return clientsData;
  }

  /// This method returns Json String [Client]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Client]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Client]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnClient!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Client>>
  Future<List<DropdownMenuItem<Client>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Client>> o)?
          dropDownMenu]) async {
    buildParameters();
    final clientsFuture = _mnClient!.toList(qparams);

    final data = await clientsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Client>> items = []..add(DropdownMenuItem(
        value: Client(),
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Client.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final clientsFuture = _mnClient!.toList(qparams);

    final data = await clientsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Client]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM Client WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnClient!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Client]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnClient!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Client.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnClient!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ClientFilterBuilder

// region ClientFields
class ClientFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fCompanyName;
  static TableField get companyName {
    return _fCompanyName = _fCompanyName ??
        SqlSyntax.setField(_fCompanyName, 'companyName', DbType.text);
  }

  static TableField? _fBankName;
  static TableField get bankName {
    return _fBankName =
        _fBankName ?? SqlSyntax.setField(_fBankName, 'bankName', DbType.text);
  }

  static TableField? _fBankNumber;
  static TableField get bankNumber {
    return _fBankNumber = _fBankNumber ??
        SqlSyntax.setField(_fBankNumber, 'bankNumber', DbType.text);
  }

  static TableField? _fTinNumber;
  static TableField get tinNumber {
    return _fTinNumber = _fTinNumber ??
        SqlSyntax.setField(_fTinNumber, 'tinNumber', DbType.text);
  }

  static TableField? _fCity;
  static TableField get city {
    return _fCity = _fCity ?? SqlSyntax.setField(_fCity, 'city', DbType.text);
  }

  static TableField? _fPhoneN;
  static TableField get phoneN {
    return _fPhoneN =
        _fPhoneN ?? SqlSyntax.setField(_fPhoneN, 'phoneN', DbType.text);
  }

  static TableField? _fPurchaseFreq;
  static TableField get purchaseFreq {
    return _fPurchaseFreq = _fPurchaseFreq ??
        SqlSyntax.setField(_fPurchaseFreq, 'purchaseFreq', DbType.integer);
  }

  static TableField? _fTotPurchase;
  static TableField get totPurchase {
    return _fTotPurchase = _fTotPurchase ??
        SqlSyntax.setField(_fTotPurchase, 'totPurchase', DbType.real);
  }

  static TableField? _fCreatedAt;
  static TableField get createdAt {
    return _fCreatedAt = _fCreatedAt ??
        SqlSyntax.setField(_fCreatedAt, 'createdAt', DbType.datetime);
  }

  static TableField? _fUpdatedAt;
  static TableField get updatedAt {
    return _fUpdatedAt = _fUpdatedAt ??
        SqlSyntax.setField(_fUpdatedAt, 'updatedAt', DbType.datetime);
  }
}
// endregion ClientFields

//region ClientManager
class ClientManager extends SqfEntityProvider {
  ClientManager()
      : super(MyStoreDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Client';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ClientManager
// region Expense
class Expense extends TableBase {
  Expense(
      {this.id,
      this.name,
      this.amount,
      this.type,
      this.date,
      this.createdAt,
      this.updatedAt}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Expense.withFields(this.name, this.amount, this.type, this.date,
      this.createdAt, this.updatedAt) {
    _setDefaultValues();
  }
  Expense.withId(this.id, this.name, this.amount, this.type, this.date,
      this.createdAt, this.updatedAt) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Expense.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['amount'] != null) {
      amount = double.tryParse(o['amount'].toString());
    }
    if (o['type'] != null) {
      type = o['type'].toString();
    }
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['date'].toString())!)
          : DateTime.tryParse(o['date'].toString());
    }
    if (o['createdAt'] != null) {
      createdAt = int.tryParse(o['createdAt'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['createdAt'].toString())!)
          : DateTime.tryParse(o['createdAt'].toString());
    }
    if (o['updatedAt'] != null) {
      updatedAt = int.tryParse(o['updatedAt'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['updatedAt'].toString())!)
          : DateTime.tryParse(o['updatedAt'].toString());
    }
  }
  // FIELDS (Expense)
  int? id;
  String? name;
  double? amount;
  String? type;
  DateTime? date;
  DateTime? createdAt;
  DateTime? updatedAt;

  // end FIELDS (Expense)

  static const bool _softDeleteActivated = false;
  ExpenseManager? __mnExpense;

  ExpenseManager get _mnExpense {
    return __mnExpense = __mnExpense ?? ExpenseManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (amount != null || !forView) {
      map['amount'] = amount;
    }
    if (type != null || !forView) {
      map['type'] = type;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date!.year-$date!.month-$date!.day'
          : forQuery
              ? DateTime(date!.year, date!.month, date!.day)
                  .millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (createdAt != null) {
      map['createdAt'] = forJson
          ? createdAt!.toString()
          : forQuery
              ? createdAt!.millisecondsSinceEpoch
              : createdAt;
    } else if (createdAt != null || !forView) {
      map['createdAt'] = null;
    }
    if (updatedAt != null) {
      map['updatedAt'] = forJson
          ? updatedAt!.toString()
          : forQuery
              ? updatedAt!.millisecondsSinceEpoch
              : updatedAt;
    } else if (updatedAt != null || !forView) {
      map['updatedAt'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (amount != null || !forView) {
      map['amount'] = amount;
    }
    if (type != null || !forView) {
      map['type'] = type;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date!.year-$date!.month-$date!.day'
          : forQuery
              ? DateTime(date!.year, date!.month, date!.day)
                  .millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (createdAt != null) {
      map['createdAt'] = forJson
          ? createdAt!.toString()
          : forQuery
              ? createdAt!.millisecondsSinceEpoch
              : createdAt;
    } else if (createdAt != null || !forView) {
      map['createdAt'] = null;
    }
    if (updatedAt != null) {
      map['updatedAt'] = forJson
          ? updatedAt!.toString()
          : forQuery
              ? updatedAt!.millisecondsSinceEpoch
              : updatedAt;
    } else if (updatedAt != null || !forView) {
      map['updatedAt'] = null;
    }

    return map;
  }

  /// This method returns Json String [Expense]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Expense]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      name,
      amount,
      type,
      date != null ? date!.millisecondsSinceEpoch : null,
      createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
      updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      name,
      amount,
      type,
      date != null ? date!.millisecondsSinceEpoch : null,
      createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
      updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
    ];
  }

  static Future<List<Expense>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Expense.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Expense>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Expense>[];
    try {
      objList = list
          .map((expense) => Expense.fromMap(expense as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Expense.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Expense>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Expense> objList = <Expense>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Expense.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Expense by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Expense] if exist, otherwise returns null
  Future<Expense?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Expense? obj;
    final data = await _mnExpense.getById([id]);
    if (data.length != 0) {
      obj = Expense.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Expense) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnExpense.insert(this, ignoreBatch);
    } else {
      await _mnExpense.update(this);
    }

    return id;
  }

  /// Saves the (Expense) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnExpense.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnExpense.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Expense. Returns a new Primary Key value of Expense

  /// <returns>Returns a new Primary Key value of Expense
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Expense> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Expense> expenses,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyStoreDbModel().batchStart();
    for (final obj in expenses) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyStoreDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < expenses.length; i++) {
        if (expenses[i].id == null) {
          expenses[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnExpense.rawInsert(
          'INSERT OR REPLACE INTO Expense (id, name, amount, type, date, createdAt, updatedAt)  VALUES (?,?,?,?,?,?,?)',
          [
            id,
            name,
            amount,
            type,
            date != null ? date!.millisecondsSinceEpoch : null,
            createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
            updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Expense id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Expense id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Expense Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Expense>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Expense> expenses,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnExpense.rawInsertAll(
        'INSERT OR REPLACE INTO Expense (id, name, amount, type, date, createdAt, updatedAt)  VALUES (?,?,?,?,?,?,?)',
        expenses,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Expense

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Expense invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnExpense
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnExpense.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Expense] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ExpenseFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ExpenseFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ExpenseFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ExpenseFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    type = type ?? 'Fixed';
    date = date ?? DateTime.now();
    createdAt = createdAt ?? DateTime.now();
    updatedAt = updatedAt ?? DateTime.now();
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion expense

// region ExpenseField
class ExpenseField extends FilterBase {
  ExpenseField(ExpenseFilterBuilder expenseFB) : super(expenseFB);

  @override
  ExpenseFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder isNull() {
    return super.isNull() as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseField get not {
    return super.not as ExpenseField;
  }
}
// endregion ExpenseField

// region ExpenseFilterBuilder
class ExpenseFilterBuilder extends ConjunctionBase {
  ExpenseFilterBuilder(Expense obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnExpense = obj._mnExpense;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ExpenseManager? _mnExpense;

  /// put the sql keyword 'AND'
  @override
  ExpenseFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ExpenseFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ExpenseFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ExpenseFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ExpenseFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ExpenseFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ExpenseFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ExpenseFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ExpenseFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ExpenseFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ExpenseFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ExpenseField _setField(ExpenseField? field, String colName, DbType dbtype) {
    return ExpenseField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ExpenseField? _id;
  ExpenseField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  ExpenseField? _name;
  ExpenseField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  ExpenseField? _amount;
  ExpenseField get amount {
    return _amount = _setField(_amount, 'amount', DbType.real);
  }

  ExpenseField? _type;
  ExpenseField get type {
    return _type = _setField(_type, 'type', DbType.text);
  }

  ExpenseField? _date;
  ExpenseField get date {
    return _date = _setField(_date, 'date', DbType.date);
  }

  ExpenseField? _createdAt;
  ExpenseField get createdAt {
    return _createdAt = _setField(_createdAt, 'createdAt', DbType.datetime);
  }

  ExpenseField? _updatedAt;
  ExpenseField get updatedAt {
    return _updatedAt = _setField(_updatedAt, 'updatedAt', DbType.datetime);
  }

  /// Deletes List<Expense> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnExpense!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnExpense!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from Expense ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnExpense!.updateBatch(qparams, values);
  }

  /// This method always returns [Expense] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Expense?
  @override
  Future<Expense?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnExpense!.toList(qparams);
    final data = await objFuture;
    Expense? obj;
    if (data.isNotEmpty) {
      obj = Expense.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Expense]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Expense?
  @override
  Future<Expense> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Expense();
  }

  /// This method returns int. [Expense]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? expenseCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final expensesFuture = await _mnExpense!.toList(qparams);
    final int count = expensesFuture[0]['CNT'] as int;
    if (expenseCount != null) {
      expenseCount(count);
    }
    return count;
  }

  /// This method returns List<Expense> [Expense]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Expense>
  @override
  Future<List<Expense>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Expense> expensesData = await Expense.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return expensesData;
  }

  /// This method returns Json String [Expense]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Expense]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Expense]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnExpense!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Expense>>
  Future<List<DropdownMenuItem<Expense>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Expense>> o)?
          dropDownMenu]) async {
    buildParameters();
    final expensesFuture = _mnExpense!.toList(qparams);

    final data = await expensesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Expense>> items = []..add(DropdownMenuItem(
        value: Expense(),
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Expense.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final expensesFuture = _mnExpense!.toList(qparams);

    final data = await expensesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Expense]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM Expense WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnExpense!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Expense]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnExpense!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Expense.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnExpense!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ExpenseFilterBuilder

// region ExpenseFields
class ExpenseFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fAmount;
  static TableField get amount {
    return _fAmount =
        _fAmount ?? SqlSyntax.setField(_fAmount, 'amount', DbType.real);
  }

  static TableField? _fType;
  static TableField get type {
    return _fType = _fType ?? SqlSyntax.setField(_fType, 'type', DbType.text);
  }

  static TableField? _fDate;
  static TableField get date {
    return _fDate = _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.date);
  }

  static TableField? _fCreatedAt;
  static TableField get createdAt {
    return _fCreatedAt = _fCreatedAt ??
        SqlSyntax.setField(_fCreatedAt, 'createdAt', DbType.datetime);
  }

  static TableField? _fUpdatedAt;
  static TableField get updatedAt {
    return _fUpdatedAt = _fUpdatedAt ??
        SqlSyntax.setField(_fUpdatedAt, 'updatedAt', DbType.datetime);
  }
}
// endregion ExpenseFields

//region ExpenseManager
class ExpenseManager extends SqfEntityProvider {
  ExpenseManager()
      : super(MyStoreDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Expense';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ExpenseManager
// region Sale
class Sale extends TableBase {
  Sale(
      {this.id,
      this.ItemId,
      this.ClientId,
      this.BankId,
      this.quantity,
      this.date,
      this.revenue,
      this.info,
      this.createdAt,
      this.updatedAt}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Sale.withFields(this.ItemId, this.ClientId, this.BankId, this.quantity,
      this.date, this.revenue, this.info, this.createdAt, this.updatedAt) {
    _setDefaultValues();
  }
  Sale.withId(this.id, this.ItemId, this.ClientId, this.BankId, this.quantity,
      this.date, this.revenue, this.info, this.createdAt, this.updatedAt) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Sale.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    ItemId = int.tryParse(o['ItemId'].toString());

    ClientId = int.tryParse(o['ClientId'].toString());

    BankId = int.tryParse(o['BankId'].toString());

    if (o['quantity'] != null) {
      quantity = int.tryParse(o['quantity'].toString());
    }
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['date'].toString())!)
          : DateTime.tryParse(o['date'].toString());
    }
    if (o['revenue'] != null) {
      revenue = double.tryParse(o['revenue'].toString());
    }
    if (o['info'] != null) {
      info = o['info'].toString();
    }
    if (o['createdAt'] != null) {
      createdAt = int.tryParse(o['createdAt'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['createdAt'].toString())!)
          : DateTime.tryParse(o['createdAt'].toString());
    }
    if (o['updatedAt'] != null) {
      updatedAt = int.tryParse(o['updatedAt'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['updatedAt'].toString())!)
          : DateTime.tryParse(o['updatedAt'].toString());
    }

    // RELATIONSHIPS FromMAP
    plItem = o['item'] != null
        ? Item.fromMap(o['item'] as Map<String, dynamic>)
        : null;
    plClient = o['client'] != null
        ? Client.fromMap(o['client'] as Map<String, dynamic>)
        : null;
    plBank = o['bank'] != null
        ? Bank.fromMap(o['bank'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Sale)
  int? id;
  int? ItemId;
  int? ClientId;
  int? BankId;
  int? quantity;
  DateTime? date;
  double? revenue;
  String? info;
  DateTime? createdAt;
  DateTime? updatedAt;

  // end FIELDS (Sale)

// RELATIONSHIPS (Sale)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plItem', 'plField2'..]) or so on..
  Item? plItem;

  /// get Item By ItemId
  Future<Item?> getItem(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Item()
        .getById(ItemId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plClient', 'plField2'..]) or so on..
  Client? plClient;

  /// get Client By ClientId
  Future<Client?> getClient(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Client().getById(ClientId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plBank', 'plField2'..]) or so on..
  Bank? plBank;

  /// get Bank By BankId
  Future<Bank?> getBank(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Bank()
        .getById(BankId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Sale)

  static const bool _softDeleteActivated = false;
  SaleManager? __mnSale;

  SaleManager get _mnSale {
    return __mnSale = __mnSale ?? SaleManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (ItemId != null) {
      map['ItemId'] = forView
          ? plItem == null
              ? ItemId
              : plItem!.name
          : ItemId;
    } else if (ItemId != null || !forView) {
      map['ItemId'] = null;
    }
    if (ClientId != null) {
      map['ClientId'] = forView
          ? plClient == null
              ? ClientId
              : plClient!.name
          : ClientId;
    } else if (ClientId != null || !forView) {
      map['ClientId'] = null;
    }
    if (BankId != null) {
      map['BankId'] = forView
          ? plBank == null
              ? BankId
              : plBank!.name
          : BankId;
    } else if (BankId != null || !forView) {
      map['BankId'] = null;
    }
    if (quantity != null || !forView) {
      map['quantity'] = quantity;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date!.year-$date!.month-$date!.day'
          : forQuery
              ? DateTime(date!.year, date!.month, date!.day)
                  .millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (revenue != null || !forView) {
      map['revenue'] = revenue;
    }
    if (info != null || !forView) {
      map['info'] = info;
    }
    if (createdAt != null) {
      map['createdAt'] = forJson
          ? createdAt!.toString()
          : forQuery
              ? createdAt!.millisecondsSinceEpoch
              : createdAt;
    } else if (createdAt != null || !forView) {
      map['createdAt'] = null;
    }
    if (updatedAt != null) {
      map['updatedAt'] = forJson
          ? updatedAt!.toString()
          : forQuery
              ? updatedAt!.millisecondsSinceEpoch
              : updatedAt;
    } else if (updatedAt != null || !forView) {
      map['updatedAt'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (ItemId != null) {
      map['ItemId'] = forView
          ? plItem == null
              ? ItemId
              : plItem!.name
          : ItemId;
    } else if (ItemId != null || !forView) {
      map['ItemId'] = null;
    }
    if (ClientId != null) {
      map['ClientId'] = forView
          ? plClient == null
              ? ClientId
              : plClient!.name
          : ClientId;
    } else if (ClientId != null || !forView) {
      map['ClientId'] = null;
    }
    if (BankId != null) {
      map['BankId'] = forView
          ? plBank == null
              ? BankId
              : plBank!.name
          : BankId;
    } else if (BankId != null || !forView) {
      map['BankId'] = null;
    }
    if (quantity != null || !forView) {
      map['quantity'] = quantity;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date!.year-$date!.month-$date!.day'
          : forQuery
              ? DateTime(date!.year, date!.month, date!.day)
                  .millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (revenue != null || !forView) {
      map['revenue'] = revenue;
    }
    if (info != null || !forView) {
      map['info'] = info;
    }
    if (createdAt != null) {
      map['createdAt'] = forJson
          ? createdAt!.toString()
          : forQuery
              ? createdAt!.millisecondsSinceEpoch
              : createdAt;
    } else if (createdAt != null || !forView) {
      map['createdAt'] = null;
    }
    if (updatedAt != null) {
      map['updatedAt'] = forJson
          ? updatedAt!.toString()
          : forQuery
              ? updatedAt!.millisecondsSinceEpoch
              : updatedAt;
    } else if (updatedAt != null || !forView) {
      map['updatedAt'] = null;
    }

    return map;
  }

  /// This method returns Json String [Sale]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Sale]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ItemId,
      ClientId,
      BankId,
      quantity,
      date != null ? date!.millisecondsSinceEpoch : null,
      revenue,
      info,
      createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
      updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      ItemId,
      ClientId,
      BankId,
      quantity,
      date != null ? date!.millisecondsSinceEpoch : null,
      revenue,
      info,
      createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
      updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
    ];
  }

  static Future<List<Sale>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Sale.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Sale>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Sale>[];
    try {
      objList = list
          .map((sale) => Sale.fromMap(sale as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Sale.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Sale>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Sale> objList = <Sale>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Sale.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plItem'))) {
          obj.plItem =
              obj.plItem ?? await obj.getItem(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plClient'))) {
          obj.plClient =
              obj.plClient ?? await obj.getClient(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plBank'))) {
          obj.plBank =
              obj.plBank ?? await obj.getBank(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Sale by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Sale] if exist, otherwise returns null
  Future<Sale?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Sale? obj;
    final data = await _mnSale.getById([id]);
    if (data.length != 0) {
      obj = Sale.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plItem'))) {
          obj.plItem =
              obj.plItem ?? await obj.getItem(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plClient'))) {
          obj.plClient =
              obj.plClient ?? await obj.getClient(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plBank'))) {
          obj.plBank =
              obj.plBank ?? await obj.getBank(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Sale) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSale.insert(this, ignoreBatch);
    } else {
      await _mnSale.update(this);
    }

    return id;
  }

  /// Saves the (Sale) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSale.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSale.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Sale. Returns a new Primary Key value of Sale

  /// <returns>Returns a new Primary Key value of Sale
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Sale> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Sale> sales,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyStoreDbModel().batchStart();
    for (final obj in sales) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyStoreDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < sales.length; i++) {
        if (sales[i].id == null) {
          sales[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSale.rawInsert(
          'INSERT OR REPLACE INTO Sales (id, ItemId, ClientId, BankId, quantity, date, revenue, info, createdAt, updatedAt)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            ItemId,
            ClientId,
            BankId,
            quantity,
            date != null ? date!.millisecondsSinceEpoch : null,
            revenue,
            info,
            createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
            updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'Sale id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Sale id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Sale Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Sale>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Sale> sales,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnSale.rawInsertAll(
        'INSERT OR REPLACE INTO Sales (id, ItemId, ClientId, BankId, quantity, date, revenue, info, createdAt, updatedAt)  VALUES (?,?,?,?,?,?,?,?,?,?)',
        sales,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Sale

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Sale invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSale
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSale.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Sale] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  SaleFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SaleFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SaleFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SaleFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    quantity = quantity ?? 1;
    date = date ?? DateTime.now();
    info = info ?? '';
    createdAt = createdAt ?? DateTime.now();
    updatedAt = updatedAt ?? DateTime.now();
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion sale

// region SaleField
class SaleField extends FilterBase {
  SaleField(SaleFilterBuilder saleFB) : super(saleFB);

  @override
  SaleFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder isNull() {
    return super.isNull() as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SaleFilterBuilder;
  }

  @override
  SaleField get not {
    return super.not as SaleField;
  }
}
// endregion SaleField

// region SaleFilterBuilder
class SaleFilterBuilder extends ConjunctionBase {
  SaleFilterBuilder(Sale obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnSale = obj._mnSale;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SaleManager? _mnSale;

  /// put the sql keyword 'AND'
  @override
  SaleFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SaleFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SaleFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SaleFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SaleFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SaleFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SaleFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SaleFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SaleFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SaleFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SaleFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SaleField _setField(SaleField? field, String colName, DbType dbtype) {
    return SaleField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SaleField? _id;
  SaleField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  SaleField? _ItemId;
  SaleField get ItemId {
    return _ItemId = _setField(_ItemId, 'ItemId', DbType.integer);
  }

  SaleField? _ClientId;
  SaleField get ClientId {
    return _ClientId = _setField(_ClientId, 'ClientId', DbType.integer);
  }

  SaleField? _BankId;
  SaleField get BankId {
    return _BankId = _setField(_BankId, 'BankId', DbType.integer);
  }

  SaleField? _quantity;
  SaleField get quantity {
    return _quantity = _setField(_quantity, 'quantity', DbType.integer);
  }

  SaleField? _date;
  SaleField get date {
    return _date = _setField(_date, 'date', DbType.date);
  }

  SaleField? _revenue;
  SaleField get revenue {
    return _revenue = _setField(_revenue, 'revenue', DbType.real);
  }

  SaleField? _info;
  SaleField get info {
    return _info = _setField(_info, 'info', DbType.text);
  }

  SaleField? _createdAt;
  SaleField get createdAt {
    return _createdAt = _setField(_createdAt, 'createdAt', DbType.datetime);
  }

  SaleField? _updatedAt;
  SaleField get updatedAt {
    return _updatedAt = _setField(_updatedAt, 'updatedAt', DbType.datetime);
  }

  /// Deletes List<Sale> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSale!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSale!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from Sales ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSale!.updateBatch(qparams, values);
  }

  /// This method always returns [Sale] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Sale?
  @override
  Future<Sale?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSale!.toList(qparams);
    final data = await objFuture;
    Sale? obj;
    if (data.isNotEmpty) {
      obj = Sale.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plItem'))) {
          obj.plItem =
              obj.plItem ?? await obj.getItem(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plClient'))) {
          obj.plClient =
              obj.plClient ?? await obj.getClient(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plBank'))) {
          obj.plBank =
              obj.plBank ?? await obj.getBank(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Sale]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Sale?
  @override
  Future<Sale> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Sale();
  }

  /// This method returns int. [Sale]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? saleCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final salesFuture = await _mnSale!.toList(qparams);
    final int count = salesFuture[0]['CNT'] as int;
    if (saleCount != null) {
      saleCount(count);
    }
    return count;
  }

  /// This method returns List<Sale> [Sale]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Sale>
  @override
  Future<List<Sale>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Sale> salesData = await Sale.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return salesData;
  }

  /// This method returns Json String [Sale]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Sale]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Sale]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSale!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Sale>>
  Future<List<DropdownMenuItem<Sale>>> toDropDownMenu(String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Sale>> o)?
          dropDownMenu]) async {
    buildParameters();
    final salesFuture = _mnSale!.toList(qparams);

    final data = await salesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Sale>> items = []..add(DropdownMenuItem(
        value: Sale(),
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Sale.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final salesFuture = _mnSale!.toList(qparams);

    final data = await salesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Sale]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM Sales WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnSale!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Sale]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSale!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Sale.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSale!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SaleFilterBuilder

// region SaleFields
class SaleFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fItemId;
  static TableField get ItemId {
    return _fItemId =
        _fItemId ?? SqlSyntax.setField(_fItemId, 'ItemId', DbType.integer);
  }

  static TableField? _fClientId;
  static TableField get ClientId {
    return _fClientId = _fClientId ??
        SqlSyntax.setField(_fClientId, 'ClientId', DbType.integer);
  }

  static TableField? _fBankId;
  static TableField get BankId {
    return _fBankId =
        _fBankId ?? SqlSyntax.setField(_fBankId, 'BankId', DbType.integer);
  }

  static TableField? _fQuantity;
  static TableField get quantity {
    return _fQuantity = _fQuantity ??
        SqlSyntax.setField(_fQuantity, 'quantity', DbType.integer);
  }

  static TableField? _fDate;
  static TableField get date {
    return _fDate = _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.date);
  }

  static TableField? _fRevenue;
  static TableField get revenue {
    return _fRevenue =
        _fRevenue ?? SqlSyntax.setField(_fRevenue, 'revenue', DbType.real);
  }

  static TableField? _fInfo;
  static TableField get info {
    return _fInfo = _fInfo ?? SqlSyntax.setField(_fInfo, 'info', DbType.text);
  }

  static TableField? _fCreatedAt;
  static TableField get createdAt {
    return _fCreatedAt = _fCreatedAt ??
        SqlSyntax.setField(_fCreatedAt, 'createdAt', DbType.datetime);
  }

  static TableField? _fUpdatedAt;
  static TableField get updatedAt {
    return _fUpdatedAt = _fUpdatedAt ??
        SqlSyntax.setField(_fUpdatedAt, 'updatedAt', DbType.datetime);
  }
}
// endregion SaleFields

//region SaleManager
class SaleManager extends SqfEntityProvider {
  SaleManager()
      : super(MyStoreDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Sales';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SaleManager
/// Region SEQUENCE IdentitySequence
class IdentitySequence {
  /// Assigns a new value when it is triggered and returns the new value
  /// returns Future<int>
  Future<int> nextVal([VoidCallback Function(int o)? nextval]) async {
    final val = await MyStoreDbModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, true);
    if (nextval != null) {
      nextval(val);
    }
    return val;
  }

  /// Get the current value
  /// returns Future<int>
  Future<int> currentVal([VoidCallback Function(int o)? currentval]) async {
    final val = await MyStoreDbModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }

  /// Reset sequence to start value
  /// returns start value
  Future<int> reset([VoidCallback Function(int o)? currentval]) async {
    final val = await MyStoreDbModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false, reset: true);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }
}

/// End Region SEQUENCE IdentitySequence

class MyStoreDbModelSequenceManager extends SqfEntityProvider {
  MyStoreDbModelSequenceManager() : super(MyStoreDbModel());
}
// END OF ENTITIES

// BEGIN CONTROLLERS
// BEGIN CONTROLLER (Personal)

class PersonalController extends Personal {
  String formListTitleField = 'name';
  String formListSubTitleField = 'createdAt';
  static SQFViewList getController = SQFViewList(
    PersonalController(),
    primaryKeyName: 'id',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};

    return menu;
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return PersonalAdd(obj == null
        ? Personal()
        : await Personal().getById(obj['id'] as int) ?? Personal());
  }
}
// END CONTROLLER (Personal)

// BEGIN CONTROLLER (Bank)
class BankToSaleControllerSub extends SaleController {
  static String relationshipFieldName = 'BankId';
  static String primaryKeyName = 'id';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'name';
  //static String formListSubTitleField = 'accountNumber';
}

class BankController extends Bank {
  String formListTitleField = 'name';
  String formListSubTitleField = 'accountNumber';
  static SQFViewList getController = SQFViewList(
    BankController(),
    primaryKeyName: 'id',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['BankToSale'] = 'Bank To Sale(BankId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'BankToSale':
        return SQFViewList(
          BankToSaleControllerSub(),
          primaryKeyName: BankToSaleControllerSub.primaryKeyName,
          useSoftDeleting: BankToSaleControllerSub.useSoftDeleting,
          //formListTitleField: 'name',
          //formListSubTitleField: 'accountNumber',
          filterExpression:
              '${BankToSaleControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return BankAdd(obj == null
        ? Bank()
        : await Bank().getById(obj['id'] as int) ?? Bank());
  }
}
// END CONTROLLER (Bank)

// BEGIN CONTROLLER (Item)
class ItemToSaleControllerSub extends SaleController {
  static String relationshipFieldName = 'ItemId';
  static String primaryKeyName = 'id';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'name';
  //static String formListSubTitleField = 'quantity';
}

class ItemController extends Item {
  String formListTitleField = 'name';
  String formListSubTitleField = 'quantity';
  static SQFViewList getController = SQFViewList(
    ItemController(),
    primaryKeyName: 'id',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['ItemToSale'] = 'Item To Sale(ItemId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'ItemToSale':
        return SQFViewList(
          ItemToSaleControllerSub(),
          primaryKeyName: ItemToSaleControllerSub.primaryKeyName,
          useSoftDeleting: ItemToSaleControllerSub.useSoftDeleting,
          //formListTitleField: 'name',
          //formListSubTitleField: 'quantity',
          filterExpression:
              '${ItemToSaleControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return ItemAdd(obj == null
        ? Item()
        : await Item().getById(obj['id'] as int) ?? Item());
  }
}
// END CONTROLLER (Item)

// BEGIN CONTROLLER (Client)
class ClientToSaleControllerSub extends SaleController {
  static String relationshipFieldName = 'ClientId';
  static String primaryKeyName = 'id';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'name';
  //static String formListSubTitleField = 'companyName';
}

class ClientController extends Client {
  String formListTitleField = 'name';
  String formListSubTitleField = 'companyName';
  static SQFViewList getController = SQFViewList(
    ClientController(),
    primaryKeyName: 'id',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['ClientToSale'] = 'Client To Sale(ClientId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'ClientToSale':
        return SQFViewList(
          ClientToSaleControllerSub(),
          primaryKeyName: ClientToSaleControllerSub.primaryKeyName,
          useSoftDeleting: ClientToSaleControllerSub.useSoftDeleting,
          //formListTitleField: 'name',
          //formListSubTitleField: 'companyName',
          filterExpression:
              '${ClientToSaleControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return ClientAdd(obj == null
        ? Client()
        : await Client().getById(obj['id'] as int) ?? Client());
  }
}
// END CONTROLLER (Client)

// BEGIN CONTROLLER (Expense)

class ExpenseController extends Expense {
  String formListTitleField = 'name';
  String formListSubTitleField = 'type';
  static SQFViewList getController = SQFViewList(
    ExpenseController(),
    primaryKeyName: 'id',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};

    return menu;
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return ExpenseAdd(obj == null
        ? Expense()
        : await Expense().getById(obj['id'] as int) ?? Expense());
  }
}
// END CONTROLLER (Expense)

// BEGIN CONTROLLER (Sale)

class SaleController extends Sale {
  String formListTitleField = 'info';
  String formListSubTitleField = 'ItemId';
  static SQFViewList getController = SQFViewList(
    SaleController(),
    primaryKeyName: 'id',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};

    return menu;
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return SaleAdd(obj == null
        ? Sale()
        : await Sale().getById(obj['id'] as int) ?? Sale());
  }
}
// END CONTROLLER (Sale)

// END OF CONTROLLERS
